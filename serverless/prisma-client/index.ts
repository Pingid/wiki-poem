// Code generated by Prisma (prisma@1.30.0). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  wikicongaLoop: (where?: WikicongaLoopWhereInput) => Promise<boolean>;
  wikicongaNode: (where?: WikicongaNodeWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  wikicongaLoop: (where: WikicongaLoopWhereUniqueInput) => WikicongaLoopPromise;
  wikicongaLoops: (
    args?: {
      where?: WikicongaLoopWhereInput;
      orderBy?: WikicongaLoopOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<WikicongaLoop>;
  wikicongaLoopsConnection: (
    args?: {
      where?: WikicongaLoopWhereInput;
      orderBy?: WikicongaLoopOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => WikicongaLoopConnectionPromise;
  wikicongaNode: (where: WikicongaNodeWhereUniqueInput) => WikicongaNodePromise;
  wikicongaNodes: (
    args?: {
      where?: WikicongaNodeWhereInput;
      orderBy?: WikicongaNodeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<WikicongaNode>;
  wikicongaNodesConnection: (
    args?: {
      where?: WikicongaNodeWhereInput;
      orderBy?: WikicongaNodeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => WikicongaNodeConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createWikicongaLoop: (data: WikicongaLoopCreateInput) => WikicongaLoopPromise;
  updateWikicongaLoop: (
    args: {
      data: WikicongaLoopUpdateInput;
      where: WikicongaLoopWhereUniqueInput;
    }
  ) => WikicongaLoopPromise;
  upsertWikicongaLoop: (
    args: {
      where: WikicongaLoopWhereUniqueInput;
      create: WikicongaLoopCreateInput;
      update: WikicongaLoopUpdateInput;
    }
  ) => WikicongaLoopPromise;
  deleteWikicongaLoop: (
    where: WikicongaLoopWhereUniqueInput
  ) => WikicongaLoopPromise;
  deleteManyWikicongaLoops: (
    where?: WikicongaLoopWhereInput
  ) => BatchPayloadPromise;
  createWikicongaNode: (data: WikicongaNodeCreateInput) => WikicongaNodePromise;
  updateWikicongaNode: (
    args: {
      data: WikicongaNodeUpdateInput;
      where: WikicongaNodeWhereUniqueInput;
    }
  ) => WikicongaNodePromise;
  updateManyWikicongaNodes: (
    args: {
      data: WikicongaNodeUpdateManyMutationInput;
      where?: WikicongaNodeWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertWikicongaNode: (
    args: {
      where: WikicongaNodeWhereUniqueInput;
      create: WikicongaNodeCreateInput;
      update: WikicongaNodeUpdateInput;
    }
  ) => WikicongaNodePromise;
  deleteWikicongaNode: (
    where: WikicongaNodeWhereUniqueInput
  ) => WikicongaNodePromise;
  deleteManyWikicongaNodes: (
    where?: WikicongaNodeWhereInput
  ) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  wikicongaLoop: (
    where?: WikicongaLoopSubscriptionWhereInput
  ) => WikicongaLoopSubscriptionPayloadSubscription;
  wikicongaNode: (
    where?: WikicongaNodeSubscriptionWhereInput
  ) => WikicongaNodeSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type WikicongaNodeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "title_ASC"
  | "title_DESC"
  | "url_ASC"
  | "url_DESC"
  | "text_ASC"
  | "text_DESC";

export type WikicongaLoopOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type WikicongaLoopWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface WikicongaNodeWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  url?: String;
  url_not?: String;
  url_in?: String[] | String;
  url_not_in?: String[] | String;
  url_lt?: String;
  url_lte?: String;
  url_gt?: String;
  url_gte?: String;
  url_contains?: String;
  url_not_contains?: String;
  url_starts_with?: String;
  url_not_starts_with?: String;
  url_ends_with?: String;
  url_not_ends_with?: String;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  children_every?: WikicongaNodeWhereInput;
  children_some?: WikicongaNodeWhereInput;
  children_none?: WikicongaNodeWhereInput;
  AND?: WikicongaNodeWhereInput[] | WikicongaNodeWhereInput;
  OR?: WikicongaNodeWhereInput[] | WikicongaNodeWhereInput;
  NOT?: WikicongaNodeWhereInput[] | WikicongaNodeWhereInput;
}

export interface WikicongaLoopWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  startNode?: WikicongaNodeWhereInput;
  AND?: WikicongaLoopWhereInput[] | WikicongaLoopWhereInput;
  OR?: WikicongaLoopWhereInput[] | WikicongaLoopWhereInput;
  NOT?: WikicongaLoopWhereInput[] | WikicongaLoopWhereInput;
}

export type WikicongaNodeWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  url?: String;
}>;

export interface WikicongaLoopCreateInput {
  startNode: WikicongaNodeCreateOneInput;
}

export interface WikicongaNodeCreateOneInput {
  create?: WikicongaNodeCreateInput;
  connect?: WikicongaNodeWhereUniqueInput;
}

export interface WikicongaNodeCreateInput {
  title: String;
  url: String;
  text: String;
  children?: WikicongaNodeCreateManyInput;
}

export interface WikicongaNodeCreateManyInput {
  create?: WikicongaNodeCreateInput[] | WikicongaNodeCreateInput;
  connect?: WikicongaNodeWhereUniqueInput[] | WikicongaNodeWhereUniqueInput;
}

export interface WikicongaLoopUpdateInput {
  startNode?: WikicongaNodeUpdateOneRequiredInput;
}

export interface WikicongaNodeUpdateOneRequiredInput {
  create?: WikicongaNodeCreateInput;
  update?: WikicongaNodeUpdateDataInput;
  upsert?: WikicongaNodeUpsertNestedInput;
  connect?: WikicongaNodeWhereUniqueInput;
}

export interface WikicongaNodeUpdateDataInput {
  title?: String;
  url?: String;
  text?: String;
  children?: WikicongaNodeUpdateManyInput;
}

export interface WikicongaNodeUpdateManyInput {
  create?: WikicongaNodeCreateInput[] | WikicongaNodeCreateInput;
  update?:
    | WikicongaNodeUpdateWithWhereUniqueNestedInput[]
    | WikicongaNodeUpdateWithWhereUniqueNestedInput;
  upsert?:
    | WikicongaNodeUpsertWithWhereUniqueNestedInput[]
    | WikicongaNodeUpsertWithWhereUniqueNestedInput;
  delete?: WikicongaNodeWhereUniqueInput[] | WikicongaNodeWhereUniqueInput;
  connect?: WikicongaNodeWhereUniqueInput[] | WikicongaNodeWhereUniqueInput;
  set?: WikicongaNodeWhereUniqueInput[] | WikicongaNodeWhereUniqueInput;
  disconnect?: WikicongaNodeWhereUniqueInput[] | WikicongaNodeWhereUniqueInput;
  deleteMany?: WikicongaNodeScalarWhereInput[] | WikicongaNodeScalarWhereInput;
  updateMany?:
    | WikicongaNodeUpdateManyWithWhereNestedInput[]
    | WikicongaNodeUpdateManyWithWhereNestedInput;
}

export interface WikicongaNodeUpdateWithWhereUniqueNestedInput {
  where: WikicongaNodeWhereUniqueInput;
  data: WikicongaNodeUpdateDataInput;
}

export interface WikicongaNodeUpsertWithWhereUniqueNestedInput {
  where: WikicongaNodeWhereUniqueInput;
  update: WikicongaNodeUpdateDataInput;
  create: WikicongaNodeCreateInput;
}

export interface WikicongaNodeScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  url?: String;
  url_not?: String;
  url_in?: String[] | String;
  url_not_in?: String[] | String;
  url_lt?: String;
  url_lte?: String;
  url_gt?: String;
  url_gte?: String;
  url_contains?: String;
  url_not_contains?: String;
  url_starts_with?: String;
  url_not_starts_with?: String;
  url_ends_with?: String;
  url_not_ends_with?: String;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  AND?: WikicongaNodeScalarWhereInput[] | WikicongaNodeScalarWhereInput;
  OR?: WikicongaNodeScalarWhereInput[] | WikicongaNodeScalarWhereInput;
  NOT?: WikicongaNodeScalarWhereInput[] | WikicongaNodeScalarWhereInput;
}

export interface WikicongaNodeUpdateManyWithWhereNestedInput {
  where: WikicongaNodeScalarWhereInput;
  data: WikicongaNodeUpdateManyDataInput;
}

export interface WikicongaNodeUpdateManyDataInput {
  title?: String;
  url?: String;
  text?: String;
}

export interface WikicongaNodeUpsertNestedInput {
  update: WikicongaNodeUpdateDataInput;
  create: WikicongaNodeCreateInput;
}

export interface WikicongaNodeUpdateInput {
  title?: String;
  url?: String;
  text?: String;
  children?: WikicongaNodeUpdateManyInput;
}

export interface WikicongaNodeUpdateManyMutationInput {
  title?: String;
  url?: String;
  text?: String;
}

export interface WikicongaLoopSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: WikicongaLoopWhereInput;
  AND?:
    | WikicongaLoopSubscriptionWhereInput[]
    | WikicongaLoopSubscriptionWhereInput;
  OR?:
    | WikicongaLoopSubscriptionWhereInput[]
    | WikicongaLoopSubscriptionWhereInput;
  NOT?:
    | WikicongaLoopSubscriptionWhereInput[]
    | WikicongaLoopSubscriptionWhereInput;
}

export interface WikicongaNodeSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: WikicongaNodeWhereInput;
  AND?:
    | WikicongaNodeSubscriptionWhereInput[]
    | WikicongaNodeSubscriptionWhereInput;
  OR?:
    | WikicongaNodeSubscriptionWhereInput[]
    | WikicongaNodeSubscriptionWhereInput;
  NOT?:
    | WikicongaNodeSubscriptionWhereInput[]
    | WikicongaNodeSubscriptionWhereInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface WikicongaLoop {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface WikicongaLoopPromise
  extends Promise<WikicongaLoop>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  startNode: <T = WikicongaNodePromise>() => T;
}

export interface WikicongaLoopSubscription
  extends Promise<AsyncIterator<WikicongaLoop>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  startNode: <T = WikicongaNodeSubscription>() => T;
}

export interface WikicongaNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  title: String;
  url: String;
  text: String;
}

export interface WikicongaNodePromise
  extends Promise<WikicongaNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  url: () => Promise<String>;
  text: () => Promise<String>;
  children: <T = FragmentableArray<WikicongaNode>>(
    args?: {
      where?: WikicongaNodeWhereInput;
      orderBy?: WikicongaNodeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface WikicongaNodeSubscription
  extends Promise<AsyncIterator<WikicongaNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  title: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
  text: () => Promise<AsyncIterator<String>>;
  children: <T = Promise<AsyncIterator<WikicongaNodeSubscription>>>(
    args?: {
      where?: WikicongaNodeWhereInput;
      orderBy?: WikicongaNodeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface WikicongaLoopConnection {
  pageInfo: PageInfo;
  edges: WikicongaLoopEdge[];
}

export interface WikicongaLoopConnectionPromise
  extends Promise<WikicongaLoopConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<WikicongaLoopEdge>>() => T;
  aggregate: <T = AggregateWikicongaLoopPromise>() => T;
}

export interface WikicongaLoopConnectionSubscription
  extends Promise<AsyncIterator<WikicongaLoopConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<WikicongaLoopEdgeSubscription>>>() => T;
  aggregate: <T = AggregateWikicongaLoopSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface WikicongaLoopEdge {
  node: WikicongaLoop;
  cursor: String;
}

export interface WikicongaLoopEdgePromise
  extends Promise<WikicongaLoopEdge>,
    Fragmentable {
  node: <T = WikicongaLoopPromise>() => T;
  cursor: () => Promise<String>;
}

export interface WikicongaLoopEdgeSubscription
  extends Promise<AsyncIterator<WikicongaLoopEdge>>,
    Fragmentable {
  node: <T = WikicongaLoopSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateWikicongaLoop {
  count: Int;
}

export interface AggregateWikicongaLoopPromise
  extends Promise<AggregateWikicongaLoop>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateWikicongaLoopSubscription
  extends Promise<AsyncIterator<AggregateWikicongaLoop>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface WikicongaNodeConnection {
  pageInfo: PageInfo;
  edges: WikicongaNodeEdge[];
}

export interface WikicongaNodeConnectionPromise
  extends Promise<WikicongaNodeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<WikicongaNodeEdge>>() => T;
  aggregate: <T = AggregateWikicongaNodePromise>() => T;
}

export interface WikicongaNodeConnectionSubscription
  extends Promise<AsyncIterator<WikicongaNodeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<WikicongaNodeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateWikicongaNodeSubscription>() => T;
}

export interface WikicongaNodeEdge {
  node: WikicongaNode;
  cursor: String;
}

export interface WikicongaNodeEdgePromise
  extends Promise<WikicongaNodeEdge>,
    Fragmentable {
  node: <T = WikicongaNodePromise>() => T;
  cursor: () => Promise<String>;
}

export interface WikicongaNodeEdgeSubscription
  extends Promise<AsyncIterator<WikicongaNodeEdge>>,
    Fragmentable {
  node: <T = WikicongaNodeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateWikicongaNode {
  count: Int;
}

export interface AggregateWikicongaNodePromise
  extends Promise<AggregateWikicongaNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateWikicongaNodeSubscription
  extends Promise<AsyncIterator<AggregateWikicongaNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface WikicongaLoopSubscriptionPayload {
  mutation: MutationType;
  node: WikicongaLoop;
  updatedFields: String[];
  previousValues: WikicongaLoopPreviousValues;
}

export interface WikicongaLoopSubscriptionPayloadPromise
  extends Promise<WikicongaLoopSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = WikicongaLoopPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = WikicongaLoopPreviousValuesPromise>() => T;
}

export interface WikicongaLoopSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<WikicongaLoopSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = WikicongaLoopSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = WikicongaLoopPreviousValuesSubscription>() => T;
}

export interface WikicongaLoopPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface WikicongaLoopPreviousValuesPromise
  extends Promise<WikicongaLoopPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface WikicongaLoopPreviousValuesSubscription
  extends Promise<AsyncIterator<WikicongaLoopPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface WikicongaNodeSubscriptionPayload {
  mutation: MutationType;
  node: WikicongaNode;
  updatedFields: String[];
  previousValues: WikicongaNodePreviousValues;
}

export interface WikicongaNodeSubscriptionPayloadPromise
  extends Promise<WikicongaNodeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = WikicongaNodePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = WikicongaNodePreviousValuesPromise>() => T;
}

export interface WikicongaNodeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<WikicongaNodeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = WikicongaNodeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = WikicongaNodePreviousValuesSubscription>() => T;
}

export interface WikicongaNodePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  title: String;
  url: String;
  text: String;
}

export interface WikicongaNodePreviousValuesPromise
  extends Promise<WikicongaNodePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  url: () => Promise<String>;
  text: () => Promise<String>;
}

export interface WikicongaNodePreviousValuesSubscription
  extends Promise<AsyncIterator<WikicongaNodePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  title: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
  text: () => Promise<AsyncIterator<String>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "WikicongaNode",
    embedded: false
  },
  {
    name: "WikicongaLoop",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `http://wikic-publi-k7xafjambn29-801764650.eu-west-2.elb.amazonaws.com/`
});
export const prisma = new Prisma();
